
import { getSupabase } from '@/services/authService';
import { Profile, UserQuizAttempt } from '@/types';

// --- SQL to execute in Supabase SQL Editor ---
/*
-- 1. Create user_exercise_progress table
CREATE TABLE public.user_exercise_progress (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    exercise_id text not null,
    completed_at timestamp with time zone default now() not null,
    constraint user_exercise_progress_user_id_exercise_id_key unique (user_id, exercise_id)
);
-- 2. Enable RLS
ALTER TABLE public.user_exercise_progress ENABLE ROW LEVEL SECURITY;
-- 3. Policies for user_exercise_progress
CREATE POLICY "Users can view their own progress."
    ON public.user_exercise_progress FOR SELECT
    USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own progress."
    ON public.user_exercise_progress FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- 4. Create user_quiz_attempts table
CREATE TABLE public.user_quiz_attempts (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    quiz_id text not null,
    score integer not null,
    total_questions integer not null,
    taken_at timestamp with time zone default now() not null,
    chapter_id text -- Added for easier querying
);
-- 5. Enable RLS
ALTER TABLE public.user_quiz_attempts ENABLE ROW LEVEL SECURITY;
-- 6. Policies for user_quiz_attempts
CREATE POLICY "Users can view their own quiz attempts."
    ON public.user_quiz_attempts FOR SELECT
    USING (auth.uid() = user_id);
CREATE POLICY "Users can insert their own quiz attempts."
    ON public.user_quiz_attempts FOR INSERT
    WITH CHECK (auth.uid() = user_id);
*/

const XP_PER_LEVEL = 150;

/**
 * Calculates the user's level based on their total XP.
 * @param xp The total experience points.
 * @returns The calculated level.
 */
export const calculateLevel = (xp: number): number => {
    return Math.floor(xp / XP_PER_LEVEL) + 1;
};

/**
 * Calculates the total XP required to reach a specific level.
 * @param level The target level.
 * @returns The total XP required.
 */
export const getXPForLevel = (level: number): number => {
    if (level <= 1) return 0;
    return (level - 1) * XP_PER_LEVEL;
};

/**
 * Records that a user has completed an exercise and updates their XP.
 * This function uses an RPC call to a Supabase function for atomicity.
 * @param userId The ID of the user.
 * @param exerciseId The ID of the completed exercise.
 * @param xpGained The amount of XP to award.
 */
export const completeExercise = async (userId: string, exerciseId: string, xpGained: number): Promise<void> => {
    const supabase = getSupabase();
    
    // First, record the completion
    const { error: progressError } = await (supabase
        .from('user_exercise_progress') as any)
        .insert({ user_id: userId, exercise_id: exerciseId });

    if (progressError && progressError.code !== '23505') { // 23505 is unique_violation, we can ignore it
        console.error("Error saving exercise progress:", progressError);
        throw progressError;
    }

    // Then, update XP. We use rpc call to increment value safely.
    const { error: xpError } = await (supabase.rpc as any)('increment_xp', { user_id_param: userId, xp_to_add: xpGained });
    
    if (xpError) {
        console.error("Error updating user XP:", xpError);
        // If this fails, we should ideally roll back the progress insertion.
        // For now, we'll just log the error.
        throw xpError;
    }
};
/*
-- SQL for the increment_xp function in Supabase
CREATE OR REPLACE FUNCTION public.increment_xp(user_id_param uuid, xp_to_add integer)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE public.profiles
  SET xp = xp + xp_to_add
  WHERE id = user_id_param;
END;
$$;
*/


/**
 * Records a user's quiz attempt and updates their XP.
 * @param userId The ID of the user.
 * @param quizId The ID of the quiz.
 * @param chapterId The ID of the chapter the quiz belongs to.
 * @param score The score achieved.
 * @param totalQuestions The total number of questions in the quiz.
 * @param xpGained The amount of XP to award.
 * @returns The newly created quiz attempt object.
 */
export const logQuizAttempt = async (userId: string, quizId: string, chapterId: string, score: number, totalQuestions: number, xpGained: number): Promise<UserQuizAttempt> => {
    const supabase = getSupabase();

    // Use upsert to handle re-taking quizzes if that becomes a feature.
    // The UNIQUE constraint on (user_id, quiz_id) will make it update the existing row.
    const { data: attemptData, error: attemptError } = await (supabase
        .from('user_quiz_attempts') as any)
        .upsert({ 
            user_id: userId, 
            quiz_id: quizId, 
            chapter_id: chapterId, 
            score, 
            total_questions: totalQuestions 
        }, { onConflict: 'user_id,quiz_id' })
        .select()
        .single();


    if (attemptError) {
        console.error("Error logging quiz attempt:", attemptError);
        throw attemptError;
    }

    const { error: xpError } = await (supabase.rpc as any)('increment_xp', { user_id_param: userId, xp_to_add: xpGained });

    if (xpError) {
        console.error("Error updating user XP after quiz:", xpError);
        throw xpError;
    }
    
    return attemptData;
};

/**
 * Fetches all quiz attempts for a user for a given list of quiz IDs.
 * @param userId The user's ID.
 * @param quizIds An array of quiz IDs.
 * @returns A promise that resolves to an array of quiz attempts.
 */
export const getQuizAttemptsForQuizzes = async (userId: string, quizIds: string[]): Promise<UserQuizAttempt[]> => {
    if (quizIds.length === 0) {
        return [];
    }
    const supabase = getSupabase();
    const { data, error } = await (supabase
        .from('user_quiz_attempts') as any)
        .select('*')
        .eq('user_id', userId)
        .in('quiz_id', quizIds);
    
    if (error) {
        console.error("Error fetching quiz attempts:", error);
        throw error;
    }

    return data || [];
};

/**
 * Fetches all user profiles for the admin dashboard.
 * This should be protected by RLS to only be accessible by an admin role in a real-world scenario.
 * For this app, we assume the admin check is done in the frontend.
 * @returns A list of all user profiles.
 */
export const getAllProfiles = async (): Promise<Profile[]> => {
    const supabase = getSupabase();
    const { data, error } = await (supabase
        .from('profiles') as any)
        .select('id, email, xp');

    if (error) {
        console.error("Error fetching all profiles:", error);
        throw error;
    }

    return data.map((profile: any) => ({
        ...profile,
        level: calculateLevel(profile.xp)
    }));
};
